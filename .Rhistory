theme_light() +
theme(panel.grid.minor   = element_blank(),
panel.grid.major.x = element_blank())
ggplot(links_df) +
aes(x = APY, y = Min_Deposit, col = Category) +
geom_point() +
labs(x = 'APY',
y = 'Minimum Deposit',
col = '',
title = 'APY vs. Minimum Deposits',
caption = 'Source: bankrate.com') +
theme_light() +
theme(panel.grid.minor   = element_blank(),
panel.grid.major.x = element_blank())
links_df %>%
filter(Min_Deposit < 10^4) %>%
ggplot() +
aes(x = APY, y = Min_Deposit, col = Category) +
geom_point() +
labs(x = 'APY',
y = 'Minimum Deposit',
col = '',
title = 'APY vs. Minimum Deposits',
caption = 'Source: bankrate.com') +
theme_light() +
theme(panel.grid.minor   = element_blank(),
panel.grid.major.x = element_blank())
ggplot(links_df) +
aes(x = APY,
y = Min_Deposit,
label = Institution,
col = Category) +
geom_text() +
labs(x = 'APY',
y = 'Minimum Deposit',
col = '',
title = 'APY vs. Minimum Deposits',
caption = 'Source: bankrate.com') +
theme_light() +
theme(panel.grid.minor   = element_blank(),
panel.grid.major.x = element_blank())
ggplot(links_df) +
aes(x = APY,
y = Min_Deposit,
label = Institution,
col = Category) +
geom_text(position = position_jitter()) +
labs(x = 'APY',
y = 'Minimum Deposit',
col = '',
title = 'APY vs. Minimum Deposits',
caption = 'Source: bankrate.com') +
theme_light() +
theme(panel.grid.minor   = element_blank(),
panel.grid.major.x = element_blank())
links_df %>%
filter(Min_Deposit < 10^4) %>%
ggplot() +
aes(x = APY,
y = Min_Deposit,
label = Institution,
col = Category) +
geom_text(position = position_jitter()) +
labs(x = 'APY',
y = 'Minimum Deposit',
col = '',
title = 'APY vs. Minimum Deposits',
caption = 'Source: bankrate.com') +
theme_light() +
theme(panel.grid.minor   = element_blank(),
panel.grid.major.x = element_blank())
libs <- c('tidyverse', 'magrittr', 'flextable',
'rvest', 'plotly')
for (i in libs) {
if (!require(i, character.only = TRUE)) {
install.packages(i)
library(i, character.only = TRUE)
}
}
g1 <- ggplot(links_df) +
aes(x = APY,
y = Min_Deposit,
label = Institution,
col = Category) +
geom_text(position = position_jitter()) +
labs(x = 'APY',
y = 'Minimum Deposit',
col = '',
title = 'APY vs. Minimum Deposits',
caption = 'Source: bankrate.com') +
theme_light() +
theme(panel.grid.minor   = element_blank(),
panel.grid.major.x = element_blank())
ggplotly(g1)
apy_v_md <- function(data) {
ggplot(data) +
aes(x = APY,
y = Min_Deposit,
label = Institution,
col = Category) +
geom_text(position = position_jitter()) +
labs(x = 'APY',
y = 'Minimum Deposit',
col = '',
title = 'APY vs. Minimum Deposits',
caption = 'Source: bankrate.com') +
theme_light() +
theme(panel.grid.minor   = element_blank(),
panel.grid.major.x = element_blank())
}
g1 <- apy_v_md(links_df)
ggplotly(g1)
g2 <- links_df %>%
filter(Min_Deposit < 10^4) %>%
apy_v_md()
g2 <- links_df %>%
filter(Min_Deposit < 10^4) %>%
apy_v_md()
ggplotly(g2)
g2 <- links_df %>%
filter(Min_Deposit < 10^4) %>%
apy_v_md(title = 'APY vs. Minimum Deposits (Outliers Removed)')
apy_v_md <- function(data, title) {
ggplot(data) +
aes(x = APY,
y = Min_Deposit,
label = Institution,
col = Category) +
geom_text(position = position_jitter()) +
labs(x = 'APY',
y = 'Minimum Deposit',
col = '',
title = title,
caption = 'Source: bankrate.com') +
theme_light() +
theme(panel.grid.minor   = element_blank(),
panel.grid.major.x = element_blank())
}
g1 <- apy_v_md(links_df, title = 'APY vs. Minimum Deposits')
ggplotly(g1)
g2 <- links_df %>%
filter(Min_Deposit < 10^4) %>%
apy_v_md(title = 'APY vs. Minimum Deposits (Outliers Removed)')
ggplotly(g2)
blogdown:::update_meta_addin()
blogdown:::serve_site()
blogdown::install_theme('nathancday/min_night')
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
JuliaCall::julia_exists()
blogdown:::new_post_addin()
library(diagnoser)
# OLS case
model.lm <- lm(data = mtcars, formula = mpg ~ wt + gear)
diagnose(model.lm,
fit_type      = 'response',
residual_type = 'response')
ggdiagnose(model.lm,
fit_type      = 'response',
residual_type = 'response',
freqpct       = TRUE,
alpha         = 0.5)
model.lm <- lm(data = mtcars, formula = mpg ~ wt + gear)
diagnose(model.lm,
fit_type      = 'response',
residual_type = 'response')
blogdown:::serve_site()
with(mtcars, plot(wt ~ mpg, pch = 1, type = 'n',
xlab = 'MPG',
ylab = 'Weight',
main = 'Weight vs. MPG'))
# Plot the labels on the graph.
with(mtcars, text(mpg, wt, row.names(mtcars),
pos = 3, cex=0.0, col = 'cyan4'))
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::new_post_addin()
library(knitr)
library(kableExtra)
# Summary Table
summ <- function(data, caption) {
summ_dat <- kable(data,
booktabs = TRUE,
caption  = caption,
linesep  = '') %>%
kable_styling(full_width    = TRUE,
latex_options = "hold_position") %>%
row_spec(1:(NROW(data)-1),
hline_after = TRUE)
summ_dat
}
```{r}
summ_strings <- data.frame(Function = c('paste(x, y)/paste0(x, y)',
"strsplit(x, split = ' ')",
'gsub(pattern, replacement, x)',
'grep/grepl(pattern, vector)'),
Description = c('Concatenation of x and y.',
'Split a string by a splitting character.',
'Substitute a portion of a string vector based on a given pattern.',
'Pattern match a string and output its position OR Boolean (i.e. TRUE/FALSE).'),
Example = c("paste('a', 'b'); paste0('a', 'b')",
"x <- c('This is a sentence.',
'This is another sentence.',
'This is yet another sentence.')
\n strsplit(x, split = ' ')",
"gsub('sentence', 'drink', x)",
"grep('^M', rownames(mtcars), value = TRUE)"))
summ(summ_strings, 'Summary of String Functions')
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
funs <- data.frame(Function = c('lapply(X, FUN)',
'sapply(X, FUN)',
'apply(X, MARGIN, FUN)',
'vapply(X, FUN, FUN.VALUE)',
'mapply(FUN, ...)',
'Map(f, ...)',
'rapply(object, f, classes)',
'aggregate(formula, data, FUN)'),
Description = c('Compute a function over data and output a list.',
'Compute a function over data and output a matrix (sometimes a list, depending on the function being passed).',
'Compute a function row-wise or column-wise.',
'Compute a function over data and check if the output matches a pre-specified type.',
'Compute a function over one or more data inputs and output an array (vector or matrix).',
'Compute a function over one or more data inputs and output a list.',
'Recursively compute a function over data and output a vector or list.',
'Generate grouped computations and output a data frame.'),
Example     = c('lapply(mtcars, mean)',
'sapply(mtcars, mean)',
'apply(mtcars, 1, mean); apply(mtcars, 2, mean)',
'vapply(mtcars, mean, numeric(1))',
'mapply(rbind, mtcars\\$mpg, mtcars\\$wt)',
'Map(rbind, mtcars\\$mpg, mtcars\\$wt)',
'rapply(iris, mean, classes = "numeric")',
'aggregate(mpg ~ gear, mtcars, mean)'))
#summ_funs <- summ(funs, caption = 'Summary of Functionals')
summ_funs <- flextable(funs) %>%
set_caption(caption = 'Summary of Functionals')
library(knitr)
library(kableExtra)
library(flextable)
# Summary Table
summ <- function(data, caption) {
summ_dat <- kable(data,
booktabs = TRUE,
caption  = caption,
linesep  = '') %>%
kable_styling(full_width    = TRUE,
latex_options = "hold_position") %>%
row_spec(1:(NROW(data)-1),
hline_after = TRUE)
summ_dat
}
funs <- data.frame(Function = c('lapply(X, FUN)',
'sapply(X, FUN)',
'apply(X, MARGIN, FUN)',
'vapply(X, FUN, FUN.VALUE)',
'mapply(FUN, ...)',
'Map(f, ...)',
'rapply(object, f, classes)',
'aggregate(formula, data, FUN)'),
Description = c('Compute a function over data and output a list.',
'Compute a function over data and output a matrix (sometimes a list, depending on the function being passed).',
'Compute a function row-wise or column-wise.',
'Compute a function over data and check if the output matches a pre-specified type.',
'Compute a function over one or more data inputs and output an array (vector or matrix).',
'Compute a function over one or more data inputs and output a list.',
'Recursively compute a function over data and output a vector or list.',
'Generate grouped computations and output a data frame.'),
Example     = c('lapply(mtcars, mean)',
'sapply(mtcars, mean)',
'apply(mtcars, 1, mean); apply(mtcars, 2, mean)',
'vapply(mtcars, mean, numeric(1))',
'mapply(rbind, mtcars\\$mpg, mtcars\\$wt)',
'Map(rbind, mtcars\\$mpg, mtcars\\$wt)',
'rapply(iris, mean, classes = "numeric")',
'aggregate(mpg ~ gear, mtcars, mean)'))
#summ_funs <- summ(funs, caption = 'Summary of Functionals')
summ_funs <- flextable(funs) %>%
set_caption(caption = 'Summary of Functionals')
summ_funs
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
### Stance Analysis of Welterweight winners
### 1. Load libraries
library(tidyverse)
library(magrittr)
### 2. Import data.
csv_files  <- grep('\\.csv', list.files(), value = TRUE)
data <- map(csv_files, ~ read_csv(.x)) %>%
set_names(csv_files) %>%
map2(csv_files, ~ mutate(.x, file_name = .y))
### 3. Filter for welterweights.
ww <- data$preprocessed_data.csv %>%
select(Winner,
title_bout,
no_of_rounds,
matches('Stance|age|Weight|Height', ignore.case = FALSE),
weight_class_Welterweight) %>%
filter(weight_class_Welterweight == 1)
### 4. Welterweight profiles: stances
stance_vs <- ww %>%
select(matches('_Stance')) %>%
map(~ with(ww, table(Winner, .x)))
for (i in 1:length(stance_vs)) {
names(attr(stance_vs[[i]], 'dimnames'))[2] <- names(stance_vs)[i]
}
stance_vs
data
blogdown:::new_post_addin()
### Stance Analysis of Welterweight Winners
### 1. Load libraries
library(tidyverse)
library(magrittr)
library(afp) # devtools::install_github('robertschnitman/afp')
### Stance Analysis of Welterweight Winners
### 1. Load libraries
library(tidyverse)
library(magrittr)
library(afp) # devtools::install_github('robertschnitman/afp')
rm(list = ls()
### 2. Import data.
data <- read_csv('data/preprocessed_data.csv')
library(afp)
### Stance Analysis of Welterweight Winners
### 1. Load libraries
library(tidyverse)
library(magrittr)
library(afp)
### 2. Import data.
data <- read_csv('data/preprocessed_data.csv')
### Stance Analysis of Welterweight Winners
### 1. Load libraries
library(tidyverse)
library(magrittr)
# devtools::install_github('robertschnitman/afp')
library(afp)
### 2. Import data.
data <- read_csv('data/preprocessed_data.csv')
### 2. Import data.
data <- read_csv('data/preprocessed_data.csv')
### 2. Import data.
data <- read_csv('data/preprocessed_data.csv')
### 3. Filter for welterweights.
ww <- data$preprocessed_data.csv %>%
select(Winner,
title_bout,
no_of_rounds,
matches('Stance|age|Weight|Height', ignore.case = FALSE),
weight_class_Welterweight) %>%
filter(weight_class_Welterweight == 1)
data
### 3. Filter for welterweights.
ww <- data %>%
select(Winner,
title_bout,
no_of_rounds,
matches('Stance|age|Weight|Height', ignore.case = FALSE),
weight_class_Welterweight) %>%
filter(weight_class_Welterweight == 1)
### 4. Welterweight profiles: stances
stance_vs <- ww %>%
select(matches('_Stance')) %>%
map(~ with(ww, table(Winner, .x)))
for (i in 1:length(stance_vs)) {
names(attr(stance_vs[[i]], 'dimnames'))[2] <- names(stance_vs)[i]
}
stance_vs2 <- stance_vs %>%
map(as.data.frame) %>%
map(~ pivot_wider(.x,
names_from = names(.x)[2],
values_from = names(.x)[3]))
stance_vs_props <- stance_vs %>%
map(prop.table) %>%
map(as.data.frame) %>%
map(~ pivot_wider(.x,
names_from = names(.x)[2],
values_from = names(.x)[3]))
# Pairbind_df is from the afp library
stance_vs_tables <- map2(stance_vs2, stance_vs_props, pairbind_df)
installed.packages()
k <- installed.packages()
str(k)
k$Package
head(k[['Package']])
head(k[, 1
])
head(k['Package'])
names(k)
colnames(k)
k[, 'Package']
stance_vs_tables
# 1. Load libraries
## CRAN
libs <- c('tidyverse', 'magrittr', 'flextable')
for (i in libs) {
if (!require(i, character.only = TRUE)) {
install.packages(i)
library(i, character.only = TRUE)
}
}
## Github
if (!'afp' %in% installed.packages()[, 'Package']) {
devtools::install_github('robertschnitman/afp')
library(afp)
}
# 1. Load libraries
## CRAN
libs <- c('tidyverse', 'magrittr', 'flextable')
for (i in libs) {
if (!require(i, character.only = TRUE)) {
install.packages(i)
library(i, character.only = TRUE)
}
}
## Github
if (!'afp' %in% installed.packages()[, 'Package']) {
devtools::install_github('robertschnitman/afp')
library(afp)
}
### 2. Import data.
data <- read_csv('data/preprocessed_data.csv')
### 3. Filter for welterweights.
ww <- data %>%
select(Winner,
title_bout,
no_of_rounds,
matches('Stance|age|Weight|Height', ignore.case = FALSE),
weight_class_Welterweight) %>%
filter(weight_class_Welterweight == 1)
stance_vs_tables
View(data)
Sys.Time
Sys.time()
Sys.Date()
stance_vs_tables2
stance_vs_tables
View(ww)
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::new_post_addin()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
library(knitr)
library(kableExtra)
library(flextable)
# Summary Table
summ <- function(data, caption) {
summ_dat <- kable(data,
booktabs = TRUE,
caption  = caption,
linesep  = '') %>%
kable_styling(full_width    = TRUE,
latex_options = "hold_position") %>%
row_spec(1:(NROW(data)-1),
hline_after = TRUE)
summ_dat
}
funs <- data.frame(Function = c('lapply(X, FUN)',
'sapply(X, FUN)',
'apply(X, MARGIN, FUN)',
'vapply(X, FUN, FUN.VALUE)',
'mapply(FUN, ...)',
'Map(f, ...)',
'rapply(object, f, classes)',
'tapply(X, INDEX, FUN)',
'aggregate(formula, data, FUN)'),
Description = c('Compute a function over data and output a list.',
'Compute a function over data and output a matrix (sometimes a list, depending on the function being passed).',
'Compute a function row-wise or column-wise.',
'Compute a function over data and check if the output matches a pre-specified type.',
'Compute a function over one or more data inputs and output an array (vector or matrix).',
'Compute a function over one or more data inputs and output a list.',
'Recursively compute a function over data and output a vector or list.',
'Generate grouped computations and output a vector.',
'Generate grouped computations and output a data frame.'),
Example     = c('lapply(mtcars, mean)',
'sapply(mtcars, mean)',
'apply(mtcars, 1, mean); apply(mtcars, 2, mean)',
'vapply(mtcars, mean, numeric(1))',
'mapply(rbind, mtcars\\$mpg, mtcars\\$wt)',
'Map(rbind, mtcars\\$mpg, mtcars\\$wt)',
'rapply(iris, mean, classes = "numeric")',
'with(iris, tapply(Sepal.Length, Species, mean))',
'aggregate(mpg ~ gear, mtcars, mean)'))
#summ_funs <- summ(funs, caption = 'Summary of Functionals')
summ_funs <- flextable(funs) %>%
set_caption(caption = 'Summary of Functionals') %>%
theme_vanilla() %>%
autofit()
summ_funs
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
